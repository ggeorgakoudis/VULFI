<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="VULFI - An LLVM based Fault Injection Framework : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>VULFI - An LLVM based Fault Injection Framework</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/utahfmr/vulfi.github.io">View on GitHub</a>

          <h1 id="project_title">VULFI - An LLVM based Fault Injection Framework</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/utahfmr/vulfi.github.io/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/utahfmr/vulfi.github.io/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h2>

<p>VULFI is an open-source instruction-level fault injection framework developed using <a href="http://llvm.org/">LLVM compiler infrastructure</a>. VULFI performs fault injection at LLVM's intermediate representation (IR) level. It currently supports C, C++, <a href="https://ispc.github.io/">ISPC</a>, <a href="https://www.khronos.org/opencl/">OpenCL</a>, and MPI-C languages. Note that to target an OpenCL program for fault injection using VULFI, the program should be compiled using <a href="https://software.intel.com/en-us/node/530783">Intel's OpenCL Compiler</a>. Conceptually, VULFI can target any high level language which can be compiled to <a href="http://llvm.org/docs/LangRef.html">LLVM's intermediate representation</a>.</p>

<p>VULFI supports all major LLVM versions starting from LLVM version 3.2. The top level VULFI directory has a master folder which contains the latest source code of VULFI supporting latest <a href="http://llvm.org/svn/llvm-project/llvm/trunk">LLVM version</a>. Also, the top level directory has additional folders starting with the prefix "LLVM_" with each folder containing VULFI source code supporting the respective version of LLVM. For example, the folder LLVM_32 contains the VULFI source code supporting LLVM version 3.2. It is our intention to keep VULFI up-to-date supporting the latest LLVM <a href="http://llvm.org/svn/llvm-project/llvm/trunk">development branch</a> while also maintaining reasonable support for older versions of LLVM.</p>

<h2>
<a id="people" class="anchor" href="#people" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>People</h2>

<h3>
<a id="faculty--collaborators" class="anchor" href="#faculty--collaborators" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Faculty &amp; Collaborators</h3>

<ul>
<li><a href="http://www.cs.utah.edu/%7Eganesh/">Ganesh Gopalakrishnan</a></li>
<li><a href="http://hpc.pnl.gov/people/sriram/">Sriram Krishnamoorthy</a></li>
</ul>

<h3>
<a id="developers" class="anchor" href="#developers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Developers</h3>

<ul>
<li><a href="https://sites.google.com/site/vishalutah/home">Vishal Sharma</a></li>
<li>Ian Briggs</li>
<li>Vinu Joseph</li>
<li>Arnab Das</li>
</ul>

<h2>
<a id="cite-our-work" class="anchor" href="#cite-our-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cite our work</h2>

<p>When you use VULFI in your research work, please cite our work using below citation information. The paper could be found <a href="http://www.cs.utah.edu/%7Evcsharma/pubs/dpdns2016-shrg.pdf">here.</a></p>

<pre><code>@inproceedings{dpdns16vulfi,
  author = {Vishal Chandra Sharma, Ganesh Gopalakrishnan, Sriram Krishnamoorthy},
  title = {Towards Reseiliency Evaluation of Vector Programs},
  booktitle = {21st IEEE Workshop on Dependable Parallel, Distributed and Network-Centric Systems (DPDNS)},
  year = {2016},
}
</code></pre>

<h2>
<a id="code-documentation" class="anchor" href="#code-documentation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Code documentation</h2>

<p>The latest doxygen code documentation of VULFI could be found <a href="http://formalverification.cs.utah.edu/fmr/vulfi/html/">here.</a></p>

<h2>
<a id="llvm-resources" class="anchor" href="#llvm-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LLVM Resources</h2>

<p>If you are new to LLVM, you may find below resources useful:</p>

<ul>
<li><a href="http://llvm.org/docs/GettingStarted.html">Getting started with LLVM </a></li>
<li><a href="http://llvm.org/docs/WritingAnLLVMPass.html">Writing an LLVM Pass</a></li>
<li><a href="http://llvm.org/docs/ProgrammersManual.html">LLVM Programmer's Manual</a></li>
<li><a href="http://llvm.org/docs/LangRef.html">LLVM Language Reference</a></li>
<li><a href="http://adriansampson.net/blog/llvm.html">Adrian Sampson's Blog on LLVM</a></li>
<li><a href="http://llvm.org/docs/CMake.html">Building LLVM with CMake</a></li>
<li><a href="http://llvm.org/docs/CMake.html#options-and-variables">LLVM CMake Variables</a></li>
<li><a href="http://llvm.org/docs/Passes.html">LLVMâ€™s Analysis and Transform Passes</a></li>
</ul>

<h2>
<a id="contact-us" class="anchor" href="#contact-us" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contact Us</h2>

<p>If you have feedback or would like to report an issue, please <a href="mailto:vulfi-dev@googlegroups.com">email us</a> or join our <a href="https://groups.google.com/forum/#!forum/vulfi-dev">mailing list</a>.</p>

<h2>
<a id="getting-started-with-vulfi" class="anchor" href="#getting-started-with-vulfi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting Started with VULFI</h2>

<h3>
<a id="software-dependencies" class="anchor" href="#software-dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Software Dependencies</h3>

<ul>
<li>LLVM (version &gt;= 3.2)</li>
<li>CMake (version &gt;= 3.0) </li>
<li>Python (version &gt;= 2.7)</li>
<li>Doxygen (version &gt;= 1.8.9)</li>
<li>Graphviz (default version)</li>
</ul>

<h3>
<a id="system-configuration" class="anchor" href="#system-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>System Configuration</h3>

<p>Below is the system configuration used for testing all versions of VULFI.</p>

<ul>
<li>CPU : Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz</li>
<li>OS : Ubuntu 15.10 (64-bit)</li>
<li>Memory : 16GB</li>
</ul>

<h3>
<a id="license--copyright-information" class="anchor" href="#license--copyright-information" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License &amp; Copyright Information</h3>

<h3>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h3>

<h5>
<a id="step-1-download-vulfi" class="anchor" href="#step-1-download-vulfi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 1: Download VULFI.</h5>

<pre><code>git clone https://github.com/utahfmr/vulfi.github.io.git &lt;vulfi dir&gt;
</code></pre>

<p>where &lt;vulfi dir&gt; is the directory where you want vulfi source code to live.</p>

<h5>
<a id="step-2-choose-the-correct-version-of-vulfi" class="anchor" href="#step-2-choose-the-correct-version-of-vulfi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 2: Choose the correct version of VULFI.</h5>

<p>If you would like to build VULFI using the latest LLVM version then go to "master" folder else refer to one of the folder starting with the prefix "LLVM_" representing your LLVM version.</p>

<pre><code>cd &lt;vulfi dir&gt;/master
</code></pre>

<h5>
<a id="step-3-create-the-build-directory" class="anchor" href="#step-3-create-the-build-directory" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 3: Create the build directory.</h5>

<pre><code>mkdir build
cd build
</code></pre>

<h5>
<a id="step-4-build--install-vulfi" class="anchor" href="#step-4-build--install-vulfi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 4: Build &amp; Install VULFI.</h5>

<p>First, run cake to generate build scripts. If everything works fine then cmake should finish without errors.</p>

<pre><code>cmake &lt;vulfi dir&gt;/master
</code></pre>

<p>Now, running make command should build VULFI library with the name LLVMVulfi.so.</p>

<pre><code>make
</code></pre>

<p>After building VULFI, you could install VULFI by running below command. Please note that the default installation directory for VULFI is ${CMAKE_INSTALL_PREFIX}/lib. On Linux systems, CMAKE_INSTALL_PREFIX points to /usr/local. </p>

<pre><code>sudo make install
</code></pre>

<p>To change the default installation directory of VULFI, you can use <a href="https://cmake.org/cmake/help/v3.0/variable/CMAKE_INSTALL_PREFIX.html">DESTDIR</a>. An example command-line given below.</p>

<pre><code>sudo make install DESTDIR=&lt;my dir&gt;
</code></pre>

<h5>
<a id="step-4-run-examples" class="anchor" href="#step-4-run-examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 4: Run examples.</h5>

<p>VULFI has some sample examples written in C and C++ which can be located at /master/examples. You can look at the "common.mk" files inside "src" and "run" subdirectories to understand how VULFI can be used for fault injection. You can compile and run all examples in one go by running below commands.</p>

<pre><code>cd &lt;vulfi dir&gt;/master/examples
make VULFI_SRC_DIR=&lt;vulfi dir&gt;/master VULFI_INSTALL_DIR=/usr/local/lib
</code></pre>

<p>Note that the variables VULFI_SRC_DIR and VULFI_INSTALL_DIR must be assigned absolute paths representing where VULFI source code lives and where VULFI library (LLVMVulfi.so) is installed respectively.</p>

<h3>
<a id="steps-for-using-vulfi-for-fault-injection" class="anchor" href="#steps-for-using-vulfi-for-fault-injection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Steps for using VULFI for Fault Injection</h3>

<p>Before reading the below documentation, please ensure that you have already executed the examples explained in the previous section, and also inspected the "common.mk" files to understand how the instrumentation and execution processes are carried out. You could pretty much use those "common.mk" files to bootstrap your fault injection process. </p>

<h5>
<a id="step-1-adding-function-calls" class="anchor" href="#step-1-adding-function-calls" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 1: Adding function calls.</h5>

<p>First, locate the code file which has the main() function. </p>

<p>If your target program is a C program then add below code snippet at the beginning of the code file.</p>

<pre><code>#ifdef INST
extern int printFaultSitesData(void);
extern int printFaultInjectionData(void);
#endif
</code></pre>

<p>If your target program is a C++ program then add below code snippet at the beginning of the code file.</p>

<pre><code>#ifdef INST
extern "C" int printFaultSitesData(void);
extern "C" int printFaultInjectionData(void);
#endif
</code></pre>

<p>Now, in the main() function, add below code snippet before all the return calls.</p>

<pre><code>#ifdef INST
  printFaultSitesData();
  printFaultInjectionData();
#endif  
</code></pre>

<h5>
<a id="command-line-options-supported-by-vulfi" class="anchor" href="#command-line-options-supported-by-vulfi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Command line options supported by VULFI</h5>

<pre><code>-fn  : Name(s) of the function(s) to be targeted
       Example: -fn "func1 func2 func3"

-fsa : Fault Site Selection Algorithm
       Options: 
        data: target all fault sites which only affect data instructions 
        (and don't affect control or address)
        dint: target all "data" fault sites of integer type (bitwdith &gt;=2)
        dflo: target all "data" fault sites of floating-point type (both 
        single and double precision)
        ctrl: target all fault sites which affect control instructions.
        addr: target all fault sites which affect address instructions.
       Example: -fsa "data"
       Default Value: data


-lang : Target language
        Options: C/C++/ISPC/OCL
        Description: This information is used by VULFI to implement language 
        specific features.
        Example: -lang "C++"
        Default Value: C++

-arch : Target architecture
        Options: x86/neon/nvvm/mips/spu
        Description: This information is used by VULFI to implement arch
        specific features. Currently, "x86" is the only supported one.
        Example: -arch "x86"
        Default Value: x86

-dbf  : Debug file name with csv extension
        Description: this CSV file provides the list of static 
        LLVM-IR instructions that will be targeted for fault injection.
</code></pre>

<h5>
<a id="step-2-instrumentation" class="anchor" href="#step-2-instrumentation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 2: Instrumentation.</h5>

<p>Suppose, we have a code file foo.cpp containing functions foo1(), foo2(), and main(), that we want to target for fault injection. </p>

<ul>
<li><p>As a first step, we need to manually add the code snippets described in Step 1 in foo.cpp and name the modified file foo_inst.cpp. Essentially, we now have two code files: foo.cpp (without code snippets) and foo_inst.cpp (with code snippets inserted).</p></li>
<li><p>Next, compile Corrupt.C (inside the runtime folder of VULFI) to LLVM bitcode as shown below.</p></li>
</ul>

<pre><code>clang++ &lt;vulfi dir&gt;/master/runtime/Corrupt.C -emit-llvm -c -o Corrupt.bc
</code></pre>

<ul>
<li>Now, compile foo.cpp and foo_inst.cpp as shown below.</li>
</ul>

<pre><code>clang++ foo.cp -emit-llvm -c -o foo.bc
clang++ foo_inst.cp -DINST -emit-llvm -c -o foo_inst.bc 
</code></pre>

<ul>
<li>We should now link both the bitcode files as shown below.</li>
</ul>

<pre><code>llvm-link Corrupt.bc foo_inst.bc -o foo_corrupt.bc
</code></pre>

<ul>
<li>
<p>Now, instrument the bitcode file foo_corrupt.bc using VULFI. For example, if we want to target all the "data" fault sites in functions foo1() and foo2() of foo.cpp code file, we should run below command.</p>

<pre><code>opt -load /usr/local/lib/LLVMVulfi.so -vulfi -fn "foo1 foo2" -fsa "data" -lang "C++" -arch "x86" \
-dbgf "fault_sites_data_foo.csv" &lt; foo_corrupt.bc &gt; foo_instrument.bc
</code></pre>
</li>
<li><p>Finally, generate the binary files using below commands.</p></li>
</ul>

<pre><code>clang++ foo.bc -o foo
clang++ foo_instrument.bc -o foo_instrument
</code></pre>

<p>The binary foo would execute the unmodified version of foo.cpp whereas the binary foo_instrument would execute the instrumented version of foo.cpp which would perform runtime fault injection.</p>

<p><strong>Please note that the instrumented version of the binary (in this case: foo_instrument) MUST NOT be executed from the terminal else you would get "segmentation fault" error. The instrumented binary expects certain configuration files which are automatically generated by a python script provided with the VULFI release. Therefore, the instrumented binary must always be executed using the python script as explained in the next step.</strong></p>

<h5>
<a id="step-3-execution" class="anchor" href="#step-3-execution" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 3: Execution.</h5>

<p>VULFI automates the fault injection process mainly consisting of <strong>execution</strong> and <strong>result generation</strong> phases, using a python script that can be located at /master/scripts/driver.py. The python script provides two modes of operation: <strong>standalone</strong> and <strong>comparison</strong> modes. In standalone mode, only instrumented binary is needed (foo_instrument) for execution. In comparison mode, we require both uninstrumented and instrumented binaries (foo and foo_instrument) for execution. At the end of the execution, result produced by both the binaries are compared to report a potential occurrence of silent data corruption. A detailed information (e.g., position of the flipped bit, targeted instruction, runtime value which is corrupted, etc.) about the fault injection is written to a CSV file. In case of multiple runs, the results from each run is appended to the same CSV file. The command-line information of python script could be printed by running below command.</p>

<pre><code>python &lt;vulfi dir&gt;/main/driver.py --help
</code></pre>

<p>Command output:</p>

<pre><code>usage: driver.py [-h] [-e] [-s] [-c] [--ov] [--pv] [--iter EXEC_COUNT]
                 [--fcp {bex,img,num}] [--th TH] [--exec1 EXEC1] [--cmd1 CMD1]
                 [--out1 OUT1] [--cho] [--cfs] [--exec2 EXEC2] [--cmd2 CMD2]
                 [--out2 OUT2] [--rslt RSLT] [--ficsv FICSV]
                 [--fia {cbr,abr,msk}] [--fib {1,2,3,4,5,6,7,8}]
                 [--fid {msb,lsb}] [--fbu FBU] [--fbl FBL] [--np NUM_PROB]
                 [--dp DEN_PROB] [--ff {eql,max,min,nlm}] [--fc FICOUNT]

Process commandline options..

optional arguments:
  -h, --help            show this help message and exit
  -e                    execution mode.
  -s                    standalone mode, always used in combination with -e option.
  -c                    comparison mode, always used in combination with -e option.
  --ov                  Calculate overhead
  --pv                  override user provided fault injection probability..
  --iter EXEC_COUNT     Number of iterations.
  --fcp {bex,img,num}   file comparison mode.
  --th TH               threshold value, only valid with --fcp=img or num.
  --exec1 EXEC1         location of the 1st executable to be executed with -s or -c mode.
  --cmd1 CMD1           command line args for the exe provided using --exec1 option.
  --out1 OUT1           name (including path) of the output generated by --exec1 option.
  --cho                 this flag indicates that use cached output for exec1 if available
  --cfs                 this flag indicates that use cached fault site count
  --exec2 EXEC2         location of the instrumented executable to be executed only with -c.
  --cmd2 CMD2           command line args for the exe provided using --exec2 option.
  --out2 OUT2           name (including path) of the output generated by --exec2 option.
  --rslt RSLT           name of the output file where result will be written
  --ficsv FICSV         name of the input csv file containing intermediate fi data.
  --fia {cbr,abr,msk}   fault injection algorithm, valid options: 
                            cbr - cumulative byte ordering; target one or more contiguous 
                            bytes for fault injection.
                            abr - absolute bit range;target a bit-range for fault injection
  --fib {1,2,3,4,5,6,7,8}
                        number of contiguous bytes to be considered for fault injection
                        Note:this option must be provided when using -fia=cbr

  --fid {msb,lsb}       direction from which no. of contiguous bytes to be considered for 
                        fault injection
                        Note:this option must be provided when using -fia=cbr

  --fbu FBU             upper bound for the fault injection bit-range.
                        Note:this option must be provided when using -fia=abr

  --fbl FBL             lower bound for the fault injection bit-range.
                        Note:this option must be provided when using -fia=abr
  --np NUM_PROB         numerator of fault injection probability expressed as a fraction.
  --dp DEN_PROB         denominator of fault injection probability expressed as a fraction.
  --ff {eql,max,min,nlm}
                        puts restriction on no. of faults that will be injected, valid options:
                            eql - execution with fault injection count equal to the val 
                            provided by --fc.
                            max - execution with fault injection count at max equal to the val 
                            provided by --fc.
                            min - execution with fault injection count at least equal to the val 
                            provided by --fc.
                            nlm - execution with fault injection count having no limit.
  --fc FICOUNT          fault injection countm this value is used in combination with --ff.
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">VULFI - An LLVM based Fault Injection Framework maintained by <a href="https://github.com/utahfmr">utahfmr</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
