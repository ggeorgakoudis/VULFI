{
  "name": "VULFI - An LLVM based Fault Injection Framework",
  "tagline": "",
  "body": "## Introduction\r\nVULFI is an open-source instruction-level fault injection framework developed using [LLVM compiler infrastructure](http://llvm.org/). VULFI performs fault injection at LLVM's intermediate representation (IR) level. It currently supports C, C++, [ISPC](https://ispc.github.io/), [OpenCL](https://www.khronos.org/opencl/), and MPI-C languages. Note that to target an OpenCL program for fault injection using VULFI, the program should be compiled using [Intel's OpenCL Compiler](https://software.intel.com/en-us/node/530783). Conceptually, VULFI can target any high level language which can be compiled to [LLVM's intermediate representation](http://llvm.org/docs/LangRef.html).\r\n\r\nVULFI supports all major LLVM versions starting from LLVM version 3.2. The top level VULFI directory has a master folder which contains the latest source code of VULFI supporting latest [LLVM version](http://llvm.org/svn/llvm-project/llvm/trunk). Also, the top level directory has additional folders starting with the prefix \"LLVM_\" with each folder containing VULFI source code supporting the respective version of LLVM. For example, the folder LLVM_32 contains the VULFI source code supporting LLVM version 3.2. It is our intention to keep VULFI up-to-date supporting the latest LLVM [development branch] (http://llvm.org/svn/llvm-project/llvm/trunk) while also maintaining reasonable support for older versions of LLVM.\r\n\r\n## People \r\n### Faculty & Collaborators\r\n* [Ganesh Gopalakrishnan](http://www.cs.utah.edu/~ganesh/)\r\n* [Sriram Krishnamoorthy](http://hpc.pnl.gov/people/sriram/)\r\n\r\n### Developers\r\n* [Vishal Sharma](https://sites.google.com/site/vishalutah/home)\r\n* Ian Briggs\r\n* Vinu Joseph\r\n* Arnab Das\r\n\r\n## Cite our work\r\nWhen you use VULFI in your research work, please cite our work using below citation information. The paper could be found [here.](http://www.cs.utah.edu/~vcsharma/pubs/dpdns2016-shrg.pdf)\r\n\r\n```\r\n@inproceedings{dpdns16vulfi,\r\n  author = {Vishal Chandra Sharma, Ganesh Gopalakrishnan, Sriram Krishnamoorthy},\r\n  title = {Towards Reseiliency Evaluation of Vector Programs},\r\n  booktitle = {21st IEEE Workshop on Dependable Parallel, Distributed and Network-Centric Systems (DPDNS)},\r\n  year = {2016},\r\n}\r\n```\r\n## Code documentation\r\nThe latest doxygen code documentation of VULFI could be found [here.](http://formalverification.cs.utah.edu/fmr/vulfi/html/)\r\n\r\n## LLVM Resources\r\nIf you are new to LLVM, you may find below resources useful:\r\n* [Getting started with LLVM ](http://llvm.org/docs/GettingStarted.html)\r\n* [Writing an LLVM Pass](http://llvm.org/docs/WritingAnLLVMPass.html)\r\n* [LLVM Programmer's Manual](http://llvm.org/docs/ProgrammersManual.html)\r\n* [LLVM Language Reference](http://llvm.org/docs/LangRef.html)\r\n* [Adrian Sampson's Blog on LLVM](http://adriansampson.net/blog/llvm.html)\r\n* [Building LLVM with CMake](http://llvm.org/docs/CMake.html)\r\n* [LLVM CMake Variables](http://llvm.org/docs/CMake.html#options-and-variables)\r\n* [LLVMâ€™s Analysis and Transform Passes](http://llvm.org/docs/Passes.html)\r\n\r\n## Contact Us\r\nIf you have feedback or would like to report an issue, please [email us](\r\nmailto:vulfi-dev@googlegroups.com) or join our [mailing list](https://groups.google.com/forum/#!forum/vulfi-dev).\r\n\r\n\r\n## Getting Started with VULFI\r\n### Software Dependencies\r\n* LLVM (version >= 3.2)\r\n* CMake (version >= 3.0) \r\n* Python (version >= 2.7)\r\n* Doxygen (version >= 1.8.9)\r\n* Graphviz (default version)\r\n\r\n### System Configuration\r\nBelow is the system configuration used for testing all versions of VULFI.\r\n* CPU : Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz\r\n* OS : Ubuntu 15.10 (64-bit)\r\n* Memory : 16GB\r\n\r\n### License & Copyright Information\r\n### Installation\r\n##### Step 1: Download VULFI. \r\n\r\n```\r\ngit clone https://github.com/utahfmr/vulfi.github.io.git <vulfi dir>\r\n```\r\nwhere \\<vulfi dir\\> is the directory where you want vulfi source code to live.\r\n\r\n##### Step 2: Choose the correct version of VULFI. \r\nIf you would like to build VULFI using the latest LLVM version then go to \"master\" folder else refer to one of the folder starting with the prefix \"LLVM_\" representing your LLVM version.\r\n\r\n```\r\ncd <vulfi dir>/master\r\n```\r\n\r\n##### Step 3: Create the build directory.\r\n\r\n```\r\nmkdir build\r\ncd build\r\n```\r\n\r\n##### Step 4: Build & Install VULFI.\r\n\r\nFirst, run cake to generate build scripts. If everything works fine then cmake should finish without errors.\r\n```\r\ncmake <vulfi dir>/master\r\n```\r\n\r\nNow, running make command should build VULFI library with the name LLVMVulfi.so.\r\n\r\n```\r\nmake\r\n```\r\n\r\nAfter building VULFI, you could install VULFI by running below command. Please note that the default installation directory for VULFI is ${CMAKE_INSTALL_PREFIX}/lib. On Linux systems, CMAKE_INSTALL_PREFIX points to /usr/local. \r\n\r\n```\r\nsudo make install\r\n```\r\n\r\nTo change the default installation directory of VULFI, you can use [DESTDIR](https://cmake.org/cmake/help/v3.0/variable/CMAKE_INSTALL_PREFIX.html). An example command-line given below.\r\n\r\n```\r\nsudo make install DESTDIR=<my dir>\r\n```\r\n\r\n##### Step 4: Run examples.\r\n\r\nVULFI has some sample examples written in C and C++ which can be located at <vulfi dir>/master/examples. You can look at the \"common.mk\" files inside \"src\" and \"run\" subdirectories to understand how VULFI can be used for fault injection. You can compile and run all examples in one go by running below commands.\r\n\r\n```\r\ncd <vulfi dir>/master/examples\r\nmake VULFI_SRC_DIR=<vulfi dir>/master VULFI_INSTALL_DIR=/usr/local/lib\r\n```\r\n\r\nNote that the variables VULFI_SRC_DIR and VULFI_INSTALL_DIR must be assigned absolute paths representing where VULFI source code lives and where VULFI library (LLVMVulfi.so) is installed respectively.\r\n\r\n\r\n\r\n### Steps for using VULFI for Fault Injection\r\nBefore reading the below documentation, please ensure that you have already executed the examples explained in the previous section, and also inspected the \"common.mk\" files to understand how the instrumentation and execution processes are carried out. You could pretty much use those \"common.mk\" files to bootstrap your fault injection process. \r\n\r\n\r\n##### Step 1: Adding function calls.\r\n\r\nFirst, locate the code file which has the main() function. \r\n\r\nIf your target program is a C program then add below code snippet at the beginning of the code file.\r\n\r\n```\r\n#ifdef INST\r\nextern int printFaultSitesData(void);\r\nextern int printFaultInjectionData(void);\r\n#endif\r\n```\r\n\r\nIf your target program is a C++ program then add below code snippet at the beginning of the code file.\r\n\r\n\r\n```\r\n#ifdef INST\r\nextern \"C\" int printFaultSitesData(void);\r\nextern \"C\" int printFaultInjectionData(void);\r\n#endif\r\n```\r\n\r\nNow, in the main() function, add below code snippet before all the return calls.\r\n\r\n```\r\n#ifdef INST\r\n  printFaultSitesData();\r\n  printFaultInjectionData();\r\n#endif  \r\n```\r\n\r\n\r\n##### Command line options supported by VULFI\r\n\r\n```\r\n-fn  : Name(s) of the function(s) to be targeted\r\n       Example: -fn \"func1 func2 func3\"\r\n\r\n-fsa : Fault Site Selection Algorithm\r\n       Options: \r\n        data: target all fault sites which only affect data instructions \r\n        (and don't affect control or address)\r\n        dint: target all \"data\" fault sites of integer type (bitwdith >=2)\r\n        dflo: target all \"data\" fault sites of floating-point type (both \r\n        single and double precision)\r\n        ctrl: target all fault sites which affect control instructions.\r\n        addr: target all fault sites which affect address instructions.\r\n       Example: -fsa \"data\"\r\n       Default Value: data\r\n       \r\n\r\n-lang : Target language\r\n        Options: C/C++/ISPC/OCL\r\n        Description: This information is used by VULFI to implement \r\n        language specific features.\r\n        Example: -lang \"C++\"\r\n        Default Value: C++\r\n\r\n-arch : Target architecture\r\n        Options: x86/neon/nvvm/mips/spu\r\n        Description: This information is used by VULFI to implement arch\r\n        specific features. Currently, \"x86\" is the only supported one.\r\n        Example: -arch \"x86\"\r\n        Default Value: x86\r\n        \r\n-dbf  : Debug file name with csv extension\r\n        Description: this CSV file provides the list of static \r\n        LLVM-IR instructions that will be targeted for fault injection.\r\n```\r\n\r\n##### Step 2: Instrumentation.\r\nSuppose, we have a code file foo.cpp containing functions foo1(), foo2(), and main(), that we want to target for fault injection. \r\n\r\n* As a first step, we need to manually add the code snippets described in Step 1 in foo.cpp and name the modified file foo_inst.cpp. Essentially, we now have two code files: foo.cpp (without code snippets) and foo_inst.cpp (with code snippets inserted).\r\n\r\n* Next, compile Corrupt.C (inside the runtime folder of VULFI) to LLVM bitcode as shown below.\r\n\r\n```\r\nclang++ <vulfi dir>/master/runtime/Corrupt.C -emit-llvm -c -o Corrupt.bc\r\n```\r\n\r\n* Now, compile foo.cpp and foo_inst.cpp as shown below.\r\n\r\n```\r\nclang++ foo.cp -emit-llvm -c -o foo.bc\r\nclang++ foo_inst.cp -DINST -emit-llvm -c -o foo_inst.bc \r\n```\r\n\r\n* We should now link both the bitcode files as shown below.\r\n\r\n```\r\nllvm-link Corrupt.bc foo_inst.bc -o foo_corrupt.bc\r\n```\r\n\r\n* Now, instrument the bitcode file foo_corrupt.bc using VULFI. For example, if we want to target all the \"data\" fault sites in functions foo1() and foo2() of foo.cpp code file, we should run below command.\r\n\r\n ```\r\nopt -load /usr/local/lib/LLVMVulfi.so -vulfi -fn \"foo1 foo2\" -fsa \"data\" -lang \"C++\" -arch \"x86\" \\\r\n-dbgf \"fault_sites_data_foo.csv\" < foo_corrupt.bc > foo_instrument.bc\r\n```\r\n\r\n* Finally, generate the binary files using below commands.\r\n\r\n```\r\nclang++ foo.bc -o foo\r\nclang++ foo_instrument.bc -o foo_instrument\r\n```\r\n\r\nThe binary foo would execute the unmodified version of foo.cpp whereas the binary foo_instrument would execute the instrumented version of foo.cpp which would perform runtime fault injection.\r\n\r\n**IMPORTANT NOTE:- Please note that the instrumented version of the binary (in this case: foo_instrument) MUST NOT be executed from the terminal else you would get \"segmentation fault\" error. The instrumented binary expects certain configuration files which are automatically generated by a python script provided with the VULFI release. Therefore, the instrumented binary must always be executed using the python script as explained in the next step.**\r\n\r\n##### Step 3: Execution.\r\nVULFI automates the fault injection process mainly consisting of **execution** and **result generation** phases, using a python script that can be located at <vulfi dir>/master/scripts/driver.py. The python script provides two modes of operation: **standalone** and **comparison** modes. In standalone mode, only instrumented binary is needed (foo\\_instrument) for execution. In comparison mode, we require both uninstrumented and instrumented binaries (foo and foo\\_instrument) for execution. At the end of the execution, result produced by both the binaries are compared to report a potential occurrence of silent data corruption. A detailed information (e.g., position of the flipped bit, targeted instruction, runtime value which is corrupted, etc.) about the fault injection is written to a CSV file. In case of multiple runs, the results from each run is appended to the same CSV file. The command-line information of python script could be printed by running below command.\r\n\r\n```\r\npython <vulfi dir>/main/driver.py --help\r\n```\r\n\r\nCommand output:\r\n\r\n```\r\nusage: driver.py [-h] [-e] [-s] [-c] [--ov] [--pv] [--iter EXEC_COUNT]\r\n                 [--fcp {bex,img,num}] [--th TH] [--exec1 EXEC1] \r\n                 [--cmd1 CMD1] [--out1 OUT1] [--cho] [--cfs] \r\n                 [--exec2 EXEC2] [--cmd2 CMD2]\r\n                 [--out2 OUT2] [--rslt RSLT] [--ficsv FICSV]\r\n                 [--fia {cbr,abr,msk}] [--fib {1,2,3,4,5,6,7,8}]\r\n                 [--fid {msb,lsb}] [--fbu FBU] [--fbl FBL] [--np NUM_PROB]\r\n                 [--dp DEN_PROB] [--ff {eql,max,min,nlm}] [--fc FICOUNT]\r\n\r\nProcess commandline options..\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  -e                    execution mode.\r\n  -s                    standalone mode, always used in combination with \r\n                        -e option.\r\n  -c                    comparison mode, always used in combination with \r\n                        -e option.\r\n  --ov                  Calculate overhead\r\n  --pv                  override user provided fault injection probability..\r\n  --iter EXEC_COUNT     Number of iterations.\r\n  --fcp {bex,img,num}   file comparison mode.\r\n  --th TH               threshold value, only valid with --fcp=img or num.\r\n  --exec1 EXEC1         location of the 1st executable to be executed with -s \r\n                        or -c mode.\r\n  --cmd1 CMD1           command line args for the exe provided using --exec1 \r\n                        option.\r\n  --out1 OUT1           name (including path) of the output generated by \r\n                        --exec1 option.\r\n  --cho                 this flag indicates that use cached output for exec1 if \r\n                        available\r\n  --cfs                 this flag indicates that use cached fault site count\r\n  --exec2 EXEC2         location of the instrumented executable to be executed \r\n                        only with -c.\r\n  --cmd2 CMD2           command line args for the exe provided using --exec2 option.\r\n  --out2 OUT2           name (including path) of the output generated by --exec2 \r\n                        option.\r\n  --rslt RSLT           name of the output file where result will be written\r\n  --ficsv FICSV         name of the input csv file containing intermediate fi data.\r\n  --fia {cbr,abr,msk}   fault injection algorithm, valid options: \r\n                         \tcbr - cumulative byte ordering; target one or more \r\n                         \tcontiguous bytes for fault injection.\r\n                        \tabr - absolute bit range;target a bit-range for fault \r\n                        \tinjection\r\n  --fib {1,2,3,4,5,6,7,8}\r\n                        number of contiguous bytes to be considered for fault \r\n                        injection\r\n                        Note:this option must be provided when using -fia=cbr\r\n                        \r\n  --fid {msb,lsb}       direction from which no. of contiguous bytes to be considered \r\n                        for \r\n                        fault injection\r\n                        Note:this option must be provided when using -fia=cbr\r\n                        \r\n  --fbu FBU             upper bound for the fault injection bit-range.\r\n                        Note:this option must be provided when using -fia=abr\r\n                        \r\n  --fbl FBL             lower bound for the fault injection bit-range.\r\n                        Note:this option must be provided when using -fia=abr\r\n  --np NUM_PROB         numerator of fault injection probability expressed as a \r\n                        fraction.\r\n  --dp DEN_PROB         denominator of fault injection probability expressed as a \r\n                        fraction.\r\n  --ff {eql,max,min,nlm}\r\n                        puts restriction on no. of faults that will be injected, \r\n                        valid options:\r\n                        \teql - execution with fault injection count equal to the \r\n                        \tval provided by --fc.\r\n                        \tmax - execution with fault injection count at max equal \r\n                        \tto the val provided by --fc.\r\n                        \tmin - execution with fault injection count at least equal \r\n                        \tto the val provided by --fc.\r\n                        \tnlm - execution with fault injection count having no limit.\r\n  --fc FICOUNT          fault injection countm this value is used in combination with \r\n                        --ff.\r\n  ```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}